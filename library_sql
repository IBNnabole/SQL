to create table
CREATE TABLE book (
  title varchar(100),
  isbn varchar(50),
  pages integer,
  price money,
  description varchar(256),
  publisher varchar(100)
);
////

to add smth in it
INSERT INTO book VALUES (
  'Postgres for Beginners',
  '0-5980-6249-1',
  25,
  4.99,
  'Learn Postgres the Easy Way',
  'Codecademy Publishing'
);
////

to select smth
SELECT * FROM book WHERE title = 'Postgres for Beginners';

SELECT * FROM book WHERE isbn = '0-5980-6249-1';
////
To delete column:

ALTER TABLE chapter DROP COLUMN content;
////

primary key:

CREATE TABLE book (
  title varchar(100),
  isbn varchar(50) PRIMARY KEY,  <-------------
  pages integer,
  price money,
  description varchar(256),
  publisher varchar(100)
);
/////////////////////////////////
узнать ограничения, наложенные на определенные столбцы в таблице, например recipe:

SELECT
  constraint_name, table_name, column_name - constraint_name <--- Чей ключ?!?
FROM
  information_schema.key_column_usage  <---- Эта штука узнает pk
WHERE
  table_name = 'recipe';

 constraint_name | table_name | column_name 
-----------------+------------+-------------
 recipe_pkey     | recipe     | id
(1 row)
///////////////////////////////////
Иногда ни один из столбцов в таблице не может однозначно идентифицировать запись. 
Когда это происходит, мы можем назначить несколько столбцов в таблице, которые будут служить первичным ключом, также известным как составной первичный ключ. 

 author_name |      book_title      
-------------+----------------------
 Liz Key     | Postgres Made Easy
 Liz Key     | Postgres for Dummies
 Tom Index   | Postgres Made Easy
 Tom Index   | Beginner Postgres

Чтобы назначить несколько столбцов составным первичным ключом:
CREATE TABLE popular_recipes (
  recipe_id varchar(20),
  ingredient_id varchar(20),
  downloaded integer,
  PRIMARY KEY (recipe_id, ingredient_id) <------
);
////
CREATE TABLE popular_books(
  book_title varchar(100),
  author_name varchar(50),
  number_sold integer,
  number_previewed integer,
  PRIMARY KEY (book_title, author_name)
);

SELECT constraint_name, table_name, column_name
FROM information_schema.key_column_usage
WHERE table_name = 'popular_books';
// output
constraint_name	    table_name	    column_name
popular_books_pkey	popular_books	  book_title
popular_books_pkey	popular_books	  author_name
/////////////////////////////////////////
Требуется ли для создания emailзаписи наличие действующей personзаписи? 
Обычно это так, поскольку мы не должны создавать адрес электронной почты для несуществующего человека. 
Следовательно, мы должны поместить внешний ключ в email таблицу, чтобы гарантировать, 
что действительная запись в personтаблице должна существовать до добавления записи в email таблицу.

CREATE TABLE person (
  id integer PRIMARY KEY,
  name varchar(20),
  age integer
);
 
CREATE TABLE email (
  email varchar(20) PRIMARY KEY,
  person_id integer REFERENCES person(id),
  storage integer,
  price money
);
//////////////////////////////////
foreign key:

CREATE TABLE book (
  title varchar(100),
  isbn varchar(50) PRIMARY KEY,
  pages integer,
  price money,
  description varchar(256),
  publisher varchar(100)
);

CREATE TABLE chapter (
  id integer PRIMARY KEY,
  number integer,
  title varchar(50),
  content varchar(1024),
  book_isbn varchar(50) REFERENCES book(isbn)
);

SELECT constraint_name, table_name, column_name
FROM information_schema.key_column_usage
WHERE table_name = 'chapter';
////

SELECT * FROM book;
SELECT * FROM chapter;

SELECT book.title AS book, chapter.title AS chapters
FROM book, chapter
WHERE book.isbn = chapter.book_isbn; <----- output table with books and this chapters, because of pk in books and fk in chapter

///////////////////////////////////////////////////////////// один-к-одному

Чтобы установить в PostgreSQL взаимно-однозначную связь между этими двумя таблицами, нам нужно назначить внешний ключ в одной из таблиц. 
нам нужно еще одно ключевое слово, UNIQUE. Добавив это ключевое слово в объявление внешнего ключа

CREATE TABLE driver (
    license_id char(20) PRIMARY KEY,
    name varchar(20),
    address varchar(100),
    date_of_birth date
);      
 
CREATE TABLE license (
    id integer PRIMARY KEY,
    state_issued varchar(20),
    date_issued date,
    date_expired  date,
    license_id char(20) REFERENCES driver(license_id) UNIQUE
); 
////////////

CREATE TABLE book_details (
  id integer PRIMARY KEY,
  book_isbn varchar(50) REFERENCES book(isbn) UNIQUE,
  rating decimal,
  language varchar(10),
  keywords text[],
  date_published date
);

SELECT constraint_name, table_name, column_name
FROM information_schema.key_column_usage
WHERE table_name = 'book_details';

INSERT INTO book VALUES (
  'Learn PostgreSQL',
  '123457890',
  100,
  2.99,
  'Great course',
  'Codecademy'
);

INSERT INTO book_details VALUES (
  1,
  '123457890',
  3.95,
  'English',
  '{sql, postgresql, database}',
  '2020-05-20'
);

SELECT book.title AS title, book.price AS price, book_details.language AS language, book_details.rating AS rating
FROM book, book_details
WHERE book.isbn = book_details.book_isbn;
//output
title	            price	  language	rating
Learn PostgreSQL	$2.99	  English	  3.95
///////////////////////////////////////////////////////// один-ко-многим

CREATE TABLE page (
  id integer PRIMARY KEY,
  chapter_id integer REFERENCES chapter(id),
  content text,
  header varchar(20),
  footer varchar(20)
);

ALTER TABLE chapter DROP COLUMN content;

SELECT constraint_name, table_name, column_name
FROM information_schema.key_column_usage
WHERE table_name = 'page';

// запрос соединяющий book, chapter и page таблицы, и отобразите результаты как book_title, chapter_title и page_content.
SELECT book.title AS book_title, chapter.title AS chapter_title, page.content AS page_content
FROM book INNER JOIN chapter
ON book.isbn = chapter.book_isbn
INNER JOIN page
ON chapter.id = page.chapter_id;

//////////////////////////////////////////////////// многие ко многим

Чтобы реализовать отношение «многие ко многим» в реляционной базе данных, 
мы должны создать третью таблицу перекрестных ссылок, также известную как таблица соединений. 
У него будут эти два ограничения:

внешние ключи, ссылающиеся на первичные ключи двух таблиц-членов.
составной первичный ключ, состоящий из двух внешних ключей.

CREATE TABLE book (
  title varchar(100),
  isbn varchar(50) PRIMARY KEY,
  pages integer,
  price money,
  description varchar(256),
  publisher varchar(100)
);

CREATE TABLE author (
  name varchar(50),
  bio varchar(100),
  email varchar(20) PRIMARY KEY
);

CREATE TABLE books_authors (
  book_isbn varchar(50) REFERENCES book(isbn),
  author_email varchar(100) REFERENCES author(email),
  PRIMARY KEY (book_isbn, author_email)
);

SELECT constraint_name, table_name, column_name
FROM information_schema.key_column_usage
WHERE table_name = 'books_authors';

////

SELECT * FROM book;

SELECT * FROM author;

INSERT INTO books_authors VALUES (
  '123457890',
  'jkey@db.com'
);

INSERT INTO books_authors VALUES (
  '123457890',
  'cindex@db.com'
);

INSERT INTO books_authors VALUES (
  '987654321',
  'cindex@db.com'
);

SELECT
    book.title AS book_title,
    author.name AS author_name,
    book.description AS book_description
FROM
    book, author, books_authors
WHERE
    book.isbn = books_authors.book_isbn
AND
    author.email = books_authors.author_email;

SELECT
    author.name AS author_name,
    author.email AS author_email,
    book.title AS book_title
FROM
    book
JOIN
    books_authors
ON
    book.isbn = books_authors.book_isbn
JOIN
    author
ON
    author.email = books_authors.author_email;






































