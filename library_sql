to create table
CREATE TABLE book (
  title varchar(100),
  isbn varchar(50),
  pages integer,
  price money,
  description varchar(256),
  publisher varchar(100)
);
////

to add smth in it
INSERT INTO book VALUES (
  'Postgres for Beginners',
  '0-5980-6249-1',
  25,
  4.99,
  'Learn Postgres the Easy Way',
  'Codecademy Publishing'
);
////

to select smth
SELECT * FROM book WHERE title = 'Postgres for Beginners';

SELECT * FROM book WHERE isbn = '0-5980-6249-1';
////
To delete column:

ALTER TABLE chapter DROP COLUMN content;
////

primary key:

CREATE TABLE book (
  title varchar(100),
  isbn varchar(50) PRIMARY KEY,  <-------------
  pages integer,
  price money,
  description varchar(256),
  publisher varchar(100)
);
/////////////////////////////////
узнать ограничения, наложенные на определенные столбцы в таблице, например recipe:

SELECT
  constraint_name, table_name, column_name - constraint_name <--- Чей ключ?!?
FROM
  information_schema.key_column_usage  <---- Эта штука узнает pk
WHERE
  table_name = 'recipe';

 constraint_name | table_name | column_name 
-----------------+------------+-------------
 recipe_pkey     | recipe     | id
(1 row)
///////////////////////////////////
Иногда ни один из столбцов в таблице не может однозначно идентифицировать запись. 
Когда это происходит, мы можем назначить несколько столбцов в таблице, которые будут служить первичным ключом, также известным как составной первичный ключ. 

 author_name |      book_title      
-------------+----------------------
 Liz Key     | Postgres Made Easy
 Liz Key     | Postgres for Dummies
 Tom Index   | Postgres Made Easy
 Tom Index   | Beginner Postgres

Чтобы назначить несколько столбцов составным первичным ключом:
CREATE TABLE popular_recipes (
  recipe_id varchar(20),
  ingredient_id varchar(20),
  downloaded integer,
  PRIMARY KEY (recipe_id, ingredient_id) <------
);
////
CREATE TABLE popular_books(
  book_title varchar(100),
  author_name varchar(50),
  number_sold integer,
  number_previewed integer,
  PRIMARY KEY (book_title, author_name)
);

SELECT constraint_name, table_name, column_name
FROM information_schema.key_column_usage
WHERE table_name = 'popular_books';
// output
constraint_name	    table_name	    column_name
popular_books_pkey	popular_books	  book_title
popular_books_pkey	popular_books	  author_name
/////////////////////////////////////////
Требуется ли для создания emailзаписи наличие действующей personзаписи? 
Обычно это так, поскольку мы не должны создавать адрес электронной почты для несуществующего человека. 
Следовательно, мы должны поместить внешний ключ в email таблицу, чтобы гарантировать, 
что действительная запись в personтаблице должна существовать до добавления записи в email таблицу.

CREATE TABLE person (
  id integer PRIMARY KEY,
  name varchar(20),
  age integer
);
 
CREATE TABLE email (
  email varchar(20) PRIMARY KEY,
  person_id integer REFERENCES person(id),
  storage integer,
  price money
);
//////////////////////////////////
foreign key:

CREATE TABLE book (
  title varchar(100),
  isbn varchar(50) PRIMARY KEY,
  pages integer,
  price money,
  description varchar(256),
  publisher varchar(100)
);

CREATE TABLE chapter (
  id integer PRIMARY KEY,
  number integer,
  title varchar(50),
  content varchar(1024),
  book_isbn varchar(50) REFERENCES book(isbn)
);

SELECT constraint_name, table_name, column_name
FROM information_schema.key_column_usage
WHERE table_name = 'chapter';
////

SELECT * FROM book;
SELECT * FROM chapter;

SELECT book.title AS book, chapter.title AS chapters
FROM book, chapter
WHERE book.isbn = chapter.book_isbn; <----- output table with books and this chapters, because of pk in books and fk in chapter

///////////////////////////////////////////////////////////// один-к-одному

Чтобы установить в PostgreSQL взаимно-однозначную связь между этими двумя таблицами, нам нужно назначить внешний ключ в одной из таблиц. 
нам нужно еще одно ключевое слово, UNIQUE. Добавив это ключевое слово в объявление внешнего ключа

CREATE TABLE driver (
    license_id char(20) PRIMARY KEY,
    name varchar(20),
    address varchar(100),
    date_of_birth date
);      
 
CREATE TABLE license (
    id integer PRIMARY KEY,
    state_issued varchar(20),
    date_issued date,
    date_expired  date,
    license_id char(20) REFERENCES driver(license_id) UNIQUE
); 
////////////

CREATE TABLE book_details (
  id integer PRIMARY KEY,
  book_isbn varchar(50) REFERENCES book(isbn) UNIQUE,
  rating decimal,
  language varchar(10),
  keywords text[],
  date_published date
);

SELECT constraint_name, table_name, column_name
FROM information_schema.key_column_usage
WHERE table_name = 'book_details';

INSERT INTO book VALUES (
  'Learn PostgreSQL',
  '123457890',
  100,
  2.99,
  'Great course',
  'Codecademy'
);

INSERT INTO book_details VALUES (
  1,
  '123457890',
  3.95,
  'English',
  '{sql, postgresql, database}',
  '2020-05-20'
);

SELECT book.title AS title, book.price AS price, book_details.language AS language, book_details.rating AS rating
FROM book, book_details
WHERE book.isbn = book_details.book_isbn;
//output
title	            price	  language	rating
Learn PostgreSQL	$2.99	  English	  3.95
///////////////////////////////////////////////////////// один-ко-многим

CREATE TABLE page (
  id integer PRIMARY KEY,
  chapter_id integer REFERENCES chapter(id),
  content text,
  header varchar(20),
  footer varchar(20)
);

ALTER TABLE chapter DROP COLUMN content;

SELECT constraint_name, table_name, column_name
FROM information_schema.key_column_usage
WHERE table_name = 'page';

// запрос соединяющий book, chapter и page таблицы, и отобразите результаты как book_title, chapter_title и page_content.
SELECT book.title AS book_title, chapter.title AS chapter_title, page.content AS page_content
FROM book INNER JOIN chapter
ON book.isbn = chapter.book_isbn
INNER JOIN page
ON chapter.id = page.chapter_id;

//////////////////////////////////////////////////// многие ко многим

Чтобы реализовать отношение «многие ко многим» в реляционной базе данных, 
мы должны создать третью таблицу перекрестных ссылок, также известную как таблица соединений. 
У него будут эти два ограничения:

внешние ключи, ссылающиеся на первичные ключи двух таблиц-членов.
составной первичный ключ, состоящий из двух внешних ключей.

CREATE TABLE book (
  title varchar(100),
  isbn varchar(50) PRIMARY KEY,
  pages integer,
  price money,
  description varchar(256),
  publisher varchar(100)
);

CREATE TABLE author (
  name varchar(50),
  bio varchar(100),
  email varchar(20) PRIMARY KEY
);

CREATE TABLE books_authors (
  book_isbn varchar(50) REFERENCES book(isbn),
  author_email varchar(100) REFERENCES author(email),
  PRIMARY KEY (book_isbn, author_email)
);

SELECT constraint_name, table_name, column_name
FROM information_schema.key_column_usage
WHERE table_name = 'books_authors';

////

SELECT * FROM book;

SELECT * FROM author;

INSERT INTO books_authors VALUES (
  '123457890',
  'jkey@db.com'
);

INSERT INTO books_authors VALUES (
  '123457890',
  'cindex@db.com'
);

INSERT INTO books_authors VALUES (
  '987654321',
  'cindex@db.com'
);

SELECT
    book.title AS book_title,
    author.name AS author_name,
    book.description AS book_description
FROM
    book, author, books_authors
WHERE
    book.isbn = books_authors.book_isbn
AND
    author.email = books_authors.author_email;

SELECT
    author.name AS author_name,
    author.email AS author_email,
    book.title AS book_title
FROM
    book
JOIN
    books_authors
ON
    book.isbn = books_authors.book_isbn
JOIN
    author
ON
    author.email = books_authors.author_email;

//////////////////////////////////////////////// constraints
NOT NULL
мы можем отклонить вставки и обновления, которые не включают данные для определенных столбцов, добавив NOT NULLограничение для этих столбцов.

CREATE TABLE talks (
    id integer,
    title varchar NOT NULL,
    speaker_id integer NOT NULL,
    estimated_length integer,
    session_timeslot timestamp NOT NULL
);// if u will write like that, and dont add all columns in insert, u will have an error

all constraints we can add with ALTER TABLE

ALTER TABLE talks
ALTER COLUMN session_timeslot SET NOT NULL; // to set constraints

ALTER TABLE talks
ALTER COLUMN session_timeslot DROP NOT NULL // to drop constraints

Если коллона не соответствует условию, то мы не сможем применить ограничения
Для этого сначала приведем ее к нужным нам отвветам

UPDATE talks
SET title = 'TBD'
WHERE title IS NULL; // вот так мы заменили NULL to TBD и теперь можно применять ограничения

//// We can use CHECK (We can add it in CREATE TABLE or ALTER TABLE)

ALTER TABLE talks 
ADD CHECK (estimated_length > 0);
------->                 or                  <--------
CREATE TABLE ...(
estimated_length integer NOT NULL CHECK (estimated_length > 0)
);
//// in CHECK we can use all SQL requests like in WHERE path (IN, LIKE, AND, OR, ...)

ALTER TABLE talks 
ADD CHECK (estimated_length > 0 AND estimated_length < 120);
ALTER TABLE talks
ADD CHECK (estimated_length < 120 AND date_part('year', session_timeslot) = 2020); // date_part функция возвращает часть даты в виде целого числа 

ALTER TABLE attendees
ADD CHECK (standard_tickets_reserved + vip_tickets_reserved = total_tickets_reserved);
//// using-unique-constraints

ALTER TABLE attendees 
ADD UNIQUE (email);

ALTER TABLE talks
ADD UNIQUE (speaker_id, session_timeslot) // один и тот же айди не может быть в неск session_timeslot одновременно

CREATE TABLE registrations (
    id integer NOT NULL,
    attendee_id integer NOT NULL,
    session_timeslot timestamp NOT NULL,
    talk_id integer NOT NULL,
    UNIQUE (attendee_id, session_timeslot)
);
///////////////////////////// more about pk

ALTER TABLE speakers
ADD PRIMARY KEY (id);

INSERT INTO speakers (email, name, organization, title, years_in_role) 
VALUES ('J.Saunders@ABCTech.com', 'Joan Saunders', 'ABC Tech.', 'Sr. Data Scientist', 6);// have an error

INSERT INTO speakers (id, email, name, organization, title, years_in_role) 
VALUES (1, 'J.Saunders@ABCTech.com', 'Joan Saunders', 'ABC Tech.', 'Sr. Data Scientist', 6);

////////////////////////// more about FOREIGN KEY

Ссылочная целостность может быть обеспечена путем добавления FOREIGN KEY к дочерней таблице, которая ссылается на первичный ключ родительской таблицы.

ALTER TABLE registrations // дочерняя табл
ADD FOREIGN KEY (talk_id)
REFERENCES talks (id);
-------> or <------------
FOREIGN KEY (talk_id) REFERENCES talks (id)// if we create table


ALTER TABLE talks
ADD FOREIGN KEY (speaker_id)
REFERENCES speakers (id);

INSERT INTO talks VALUES (
  21,
  'Data Warehousing Best Practices',
  101,
  30,
  '2020-08-15 18:00'
); // error Key (speaker_id)=(101) is not present in table “speakers”.

////////////////////////////// foreign-keys-cascading-changes

REFERENCES talks (id) ON DELETE RESTRICT or REFERENCES talks (id) ON UPDATE RESTRICT // in CREATE TABLE

OR

ALTER TABLE registrations
ADD FOREIGN KEY (talk_id)
REFERENCES talks (id) ON DELETE CASCADE
//
ALTER TABLE talks
ADD FOREIGN KEY (speaker_id)
REFERENCES speakers (id) ON DELETE CASCADE;

SELECT * FROM talks WHERE speaker_id = 2;

DELETE FROM speakers 
WHERE id = 2;

SELECT * FROM talks WHERE speaker_id = 2;














